{"/home/travis/build/npmtest/node-npmtest-laravel-elixir/test.js":"/* istanbul instrument in package npmtest_laravel_elixir */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/lib.npmtest_laravel_elixir.js":"/* istanbul instrument in package npmtest_laravel_elixir */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_laravel_elixir = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_laravel_elixir = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-laravel-elixir && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_laravel_elixir */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_laravel_elixir\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_laravel_elixir.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_laravel_elixir.rollup.js'] =\n            local.assetsDict['/assets.npmtest_laravel_elixir.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_laravel_elixir.__dirname + '/lib.npmtest_laravel_elixir.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/index.js":"var fs = require('fs');\nvar gulp = require('gulp');\nvar _ = require('underscore');\nvar gutils = require('gulp-util');\n\n/**\n * Elixir is a wrapper around Gulp.\n *\n * @param {Function} recipe\n */\nvar Elixir = function(recipe) {\n    // We'll start by loading all of the available tasks.\n    require('require-dir')('./tasks');\n\n    // The user may then choose which tasks they want.\n    recipe(Elixir.mixins);\n\n    // Now that the user has requested their desired tasks\n    // from the Gulpfile, we'll initialize everything!\n    createGulpTasks.call(Elixir);\n};\n\nElixir.mixins       = {};\nElixir.Log          = require('./Logger');\nElixir.Notification = require('./Notification');\nElixir.GulpPaths    = require('./GulpPaths');\nElixir.config       = config = require('./Config');\nElixir.Task         = require('./Task')(Elixir);\nElixir.tasks        = config.tasks;\nElixir.Plugins      = require('gulp-load-plugins')();\n\n/**\n * Register a new task with Elixir.\n *\n * @param {string}   name\n * @param {Function} callback\n */\nElixir.extend = function(name, callback) {\n    Elixir.mixins[name] = function() {\n        callback.apply(this, arguments);\n\n        return this.mixins;\n    }.bind(this);\n};\n\n/**\n * Allow for config overrides, via an elixir.json file.\n *\n * @param {string} file\n */\nElixir.setDefaultsFrom = function(file) {\n    var overrides;\n\n    if (fs.existsSync(file)) {\n        overrides = JSON.parse(fs.readFileSync(file, 'utf8'));\n\n        _.mixin({\n            deepExtend: require('underscore-deep-extend')(_)\n        });\n\n        _.deepExtend(Elixir.config, overrides);\n    }\n}('elixir.json');\n\n/**\n * Create the actual Gulp tasks dynamically,\n * based upon the chosen Elixir mixins.\n */\nvar createGulpTasks = function() {\n    var tasks = this.tasks;\n\n    tasks.forEach(function(task) {\n        if (_.contains(gulp.tasks, task.name)) return;\n\n        gulp.task(task.name, function() {\n            // If the user is running gulp watch or gulp *task from the\n            // command line, then we'll trigger the current Gulp task\n            // logic as many times as was requested in the Gulpfile.\n            // Example: mix.sass('app.scss').sass('admin.scss').\n            if (_.intersection(gutils.env._, [task.name, 'watch', 'tdd']).length) {\n                return _.where(tasks, { name: task.name })\n                    .forEach(function(task) {\n                        task.run();\n                    });\n            }\n\n            // On the other hand, if the user just triggered `gulp`,\n            // then we can simply run the task, badabingbadaboom.\n            var gulp = Elixir.Task.find(task.name).run();\n\n            // This is a little tricky. With Elixir, a single Gulp task\n            // can be triggered multiple times, with unique sets of\n            // data - which you provide, when you do mix.task().\n\n            // The kicker is that, when the Gulp task is triggered,\n            // we must know which set of data you want to use. So\n            // we increment an index each time the task is run.\n\n            // The Task.find method will then, when called, properly\n            // return the correct data that corresponds to the\n            //  active index for the current task. Got it?\n            Elixir.config.activeTasks[task.name]++;\n\n            return gulp;\n        });\n    });\n};\n\nmodule.exports = Elixir;\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/Config.js":"var p = require('path');\nvar gutils = require('gulp-util');\n\nvar production = gutils.env.production || process.env.NODE_ENV === 'production';\n\n/*\n |----------------------------------------------------------------\n | Master Configuration\n |----------------------------------------------------------------\n |\n | This file contains the proper paths and options for each and\n | and every Gulp task that Elixir wraps up. To override any\n | setting, reference elixir.config.* from your Gulpfile.\n |\n | Alternatively you may create an elixir.json file within your\n | project root. As JSON, modify any settings contained here\n | and they'll take precedence over these defaults. Easy!\n |\n */\n\nvar config = {\n\n    /*\n     |----------------------------------------------------------------\n     | Tasks\n     |----------------------------------------------------------------\n     |\n     | The tasks array stores all tasks that should be executed each\n     | time you trigger Gulp from the command line. Generally you\n     | won't need to modify this but it's an option if needed.\n     |\n     */\n\n    tasks: [],\n\n    /*\n     |----------------------------------------------------------------\n     | Production Mode\n     |----------------------------------------------------------------\n     |\n     | Elixir will trigger certain actions, dependent upon this flag.\n     | You may \"turn on\" this mode by triggering \"gulp --production\".\n     | This will enable such things, like CSS and JS minification.\n     |\n     */\n\n    production: production,\n\n    /*\n     |----------------------------------------------------------------\n     | Assets Path\n     |----------------------------------------------------------------\n     |\n     | This assets path property is prefixed to all relevant assets\n     | in your application. For example, \"resources/assets/sass\"\n     | or \"resources/assets/coffee.\" Change this if you must.\n     |\n     */\n\n    assetsPath: 'resources/assets',\n\n    /*\n     |----------------------------------------------------------------\n     | Public Path\n     |----------------------------------------------------------------\n     |\n     | Much like assets path, this public path property is prefixed to\n     | any paths in your application, that point to the public dir.\n     | It's useful, when a server requires a unique public path.\n     |\n     */\n\n    publicPath: 'public',\n\n    /*\n     |----------------------------------------------------------------\n     | App Path\n     |----------------------------------------------------------------\n     |\n     | The app path, you guessed it, specifies the path to the app\n     | folder in your project. If using Laravel, then you won't\n     | need to modify this path. Otherwise modify as needed.\n     |\n     */\n\n    appPath: 'app',\n\n    /*\n     |----------------------------------------------------------------\n     | View Path\n     |----------------------------------------------------------------\n     |\n     | Very likely, you will never need/want to modify this property.\n     | However, for the instances where your app's views directory\n     | is located in a different spot, please modify as needed.\n     |\n     */\n\n    viewPath: 'resources/views',\n\n    /*\n     |----------------------------------------------------------------\n     | Sourcemaps\n     |----------------------------------------------------------------\n     |\n     | A sourcemap is a JSON mapping, which declares a relationship\n     | between a minified file and its original source location.\n     | Quite useful for debugging, it's turned on by default.\n     |\n     */\n\n    sourcemaps: ! gutils.env.production,\n\n    /*\n     |----------------------------------------------------------------\n     | File System Event Batching\n     |----------------------------------------------------------------\n     |\n     | You likely won't need to modify this object. That said, should\n     | you need to, these settings are exclusive to the watch task.\n     | They set the limit and timeout for running batch-updates.\n     |\n     */\n\n    batchOptions: {\n        // https://github.com/floatdrop/gulp-batch#batchoptions-callback-errorhandler\n        limit: undefined,\n        timeout: 1000\n    },\n\n    css: {\n\n        /*\n         |----------------------------------------------------------------\n         | CSS Source Folder\n         |----------------------------------------------------------------\n         |\n         | This property declares the root folder for all vanilla CSS\n         | files. Note that this is the folder name, not the path.\n         | We'll stick with a general \"css\" name - makes sense.\n         |\n         */\n\n        folder: 'css',\n\n        /*\n         |----------------------------------------------------------------\n         | CSS Output Folder\n         |----------------------------------------------------------------\n         |\n         | Generally, your source files will be stored outside of your\n         | public directory, and then compiled/merged as necessary.\n         | This property represents the public specific folder.\n         |\n         */\n\n        outputFolder: 'css',\n\n        /*\n         |----------------------------------------------------------------\n         | CSS3 Autoprefixing\n         |----------------------------------------------------------------\n         |\n         | When working with any form of CSS, Elixir automatically runs\n         | your file through a CSS autoprefixer, which automatically\n         | adds or removes vendor-specific CSS3 prefixes. Useful!\n         |\n         */\n\n        autoprefix: {\n            enabled: true,\n\n            // https://www.npmjs.com/package/gulp-autoprefixer#api\n            options:  {\n                browsers: ['last 2 versions'],\n                cascade: false\n            }\n        },\n\n        /*\n         |----------------------------------------------------------------\n         | CSS3 Minification\n         |----------------------------------------------------------------\n         |\n         | When running Gulp with the production flag, any CSS will\n         | automatically be minified. This offers the benefit of\n         | reduced file sizes. Adjust any plugin option here.\n         |\n         */\n\n        cssnano: {\n            // http://cssnano.co/options\n            pluginOptions: {\n                safe: true\n            }\n        },\n\n        /*\n         |----------------------------------------------------------------\n         | Sass Compilation\n         |----------------------------------------------------------------\n         |\n         | Gone are the days of researching how to call Sass on a given\n         | folder. Simply run `mix.sass('file.scss')` and you're all\n         | set. This object sets the folder name and plugin opts.\n         |\n         */\n\n        sass: {\n            folder: 'sass',\n\n            // https://github.com/sass/node-sass#options\n            pluginOptions: {\n                outputStyle: production\n                    ? 'compressed'\n                    : 'nested',\n                precision: 10\n            }\n        },\n\n        /*\n         |----------------------------------------------------------------\n         | Less Compilation\n         |----------------------------------------------------------------\n         |\n         | Gone are the days of researching how to call Less on a given\n         | folder. Simply run `mix.less('file.less')` and you're all\n         | set. This object sets the folder name and plugin opts.\n         |\n         */\n\n        less: {\n            folder: 'less',\n\n            // https://github.com/plus3network/gulp-less#options\n            pluginOptions: {}\n        }\n    },\n\n    js: {\n\n        /*\n         |----------------------------------------------------------------\n         | JavaScript Source Folder\n         |----------------------------------------------------------------\n         |\n         | Much like the CSS folder option above, this property sets the\n         | name of the folder, not the full path, for your JavaScript\n         | source files. It then gets affixed to the \"assetsPath\".\n         |\n         */\n\n        folder: 'js',\n\n        /*\n         |----------------------------------------------------------------\n         | JavaScript Output Folder\n         |----------------------------------------------------------------\n         |\n         | Once your vanilla JavaScript files have been compiled/merged,\n         | they will be saved to your public directory. This property\n         | represents the name of the folder within that location.\n         |\n         */\n\n        outputFolder: 'js',\n\n        /*\n         |----------------------------------------------------------------\n         | Babel Compilation\n         |----------------------------------------------------------------\n         |\n         | Think of Babel as a compiler for next-generation JavaScript.\n         | If you'd like to make use of ES6 - or even ES7 features -\n         | in new apps, we make it a cinch right from the get go.\n         |\n         */\n\n        babel: {\n            // https://www.npmjs.com/package/gulp-babel#babel-options\n            options: {\n                presets: ['es2015', 'react']\n            }\n        },\n\n        /*\n         |----------------------------------------------------------------\n         | UglifyJS Parser/Compressor/Beautifier\n         |----------------------------------------------------------------\n         |\n         | UglifyJS is a JavaScript parser/compressor/beautifier.\n         | It'll minify your JavaScript with ease and has an option to\n         | mangle your code.\n         |\n         */\n\n        uglify: {\n            options: {\n                compress: {\n                    drop_console: true\n                }\n            }\n        },\n\n        /*\n         |----------------------------------------------------------------\n         | Browserify Compilation\n         |----------------------------------------------------------------\n         |\n         | Browserify allows you to pull in Node modules in the browser!\n         | Generally a pain to get up and running, Elixir offers many\n         | sensible defaults to get you up to speed super quickly.\n         |\n         */\n\n        browserify: {\n            // https://www.npmjs.com/package/browserify#usage\n            options: {\n                cache: {},\n                packageCache: {}\n            },\n\n            plugins: [],\n\n            externals: [],\n\n            transformers: [\n                {\n                    name: 'babelify',\n\n                    // https://www.npmjs.com/package/gulp-babel#babel-options\n                    options: {\n                        presets: ['es2015', 'react']\n                    }\n                },\n\n                {\n                    name: 'partialify',\n\n                    // https://www.npmjs.com/package/partialify\n                    options: {}\n                }\n            ],\n\n            watchify: {\n                enabled: false,\n\n                // https://www.npmjs.com/package/watchify#usage\n                options: {}\n            }\n        },\n\n        /*\n         |----------------------------------------------------------------\n         | CoffeeScript Compilation\n         |----------------------------------------------------------------\n         |\n         | If you prefer CoffeeScript compilation, this object stores\n         | the defaults for the Coffee folder name - not the path.\n         | When used, this value will be affixed to assetsPath.\n         |\n         */\n\n        coffee: {\n            folder: 'coffee',\n\n            // https://github.com/wearefractal/gulp-coffee#options\n            options: {}\n        }\n    },\n\n    testing: {\n\n        /*\n         |----------------------------------------------------------------\n         | PHPUnit Autotesting\n         |----------------------------------------------------------------\n         |\n         | Want to automatically trigger your PHPUnit tests. Not a problem.\n         | This object stores your default PHPUnit directory path. For a\n         | custom command, you may use the second arg to mix.phpUnit.\n         |\n         */\n\n        phpUnit: {\n            path: 'tests'\n        },\n\n        /*\n         |----------------------------------------------------------------\n         | PHPSpec Autotesting\n         |----------------------------------------------------------------\n         |\n         | Want to automatically trigger your PHPSpec tests. Not a problem.\n         | This object stores your default PHPSpec directory path. For a\n         | custom command, you may use the second arg to mix.phpSpec.\n         |\n         */\n\n        phpSpec: {\n            path: 'spec'\n        }\n    },\n\n    /*\n     |----------------------------------------------------------------\n     | File Versioning\n     |----------------------------------------------------------------\n     |\n     | If you use aggressive assets caching on your server, then you\n     | will need a way to cachebust, right? No querystring needed\n     | this time. Here you may set the default \"build\" folder.\n     |\n     */\n\n    versioning: {\n        buildFolder: 'build'\n    },\n\n    /*\n     |----------------------------------------------------------------\n     | Browsersync\n     |----------------------------------------------------------------\n     |\n     | Want to have your browser refresh instantly upon changing a bit\n     | of Sass or modifying a view? With Elixir, it has never been\n     | easier. This contains default options for the extension.\n     |\n     */\n\n    browserSync: {\n        // http://www.browsersync.io/docs/options/\n        proxy: 'homestead.app',\n        reloadOnRestart : true,\n        notify: true\n    }\n\n};\n\n/**\n * Fetch a config item, using a string dot-notation.\n *\n * @param  {string} path\n * @return {string}\n */\nconfig.get = function(path) {\n    var basePath;\n    var current = config;\n\n    var segments = path.split('.');\n\n    // If the path begins with \"assets\" or \"public,\" then\n    // we can assume that the user wants to prefix the\n    // given base url to their config path. Useful!\n\n    if (segments[0] == 'assets' || segments[0] == 'public') {\n        basePath = config[segments.shift()+'Path'];\n    }\n\n    segments.forEach(function(segment) {\n        current = current[segment];\n    });\n\n    return p.join(basePath, current);\n};\n\n\nmodule.exports = config;\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/GulpPaths.js":"var p = require('path');\nvar gutils = require('gulp-util');\nvar parsePath = require('parse-filepath');\n\n/**\n * Create a new GulpPaths constructor.\n */\nvar GulpPaths = function() {};\n\n/**\n * Set the Gulp src file(s) and path prefix.\n *\n * @param  {string|Array} src\n * @param  {string|null}  prefix\n * @return {GulpPaths}\n */\nGulpPaths.prototype.src = function(src, prefix) {\n    var self = this;\n\n    src = this.prefix(src, prefix);\n\n    if (Array.isArray(src)) {\n        // If any item in the src array is a folder\n        // then we will fetch all of the files.\n        src = src.map(function(path) {\n            if (self.parse(path).isDir) {\n                path += '/**/*';\n            }\n\n            return path;\n        });\n\n        this.src = { path: src, baseDir: prefix };\n    } else {\n        this.src = this.parse(src);\n\n        // If a directory is provided as the Gulp src,\n        // the user probably wants everything in it.\n        this.src.isDir && (this.src.path += '/**/*');\n    }\n\n    return this;\n};\n\n/**\n * Set the Gulp output path.\n *\n * @param  {string}      output\n * @param  {string|null} defaultName\n * @return {GulpPaths}\n */\nGulpPaths.prototype.output = function(output, defaultName) {\n    this.output = this.parse(output);\n\n    // If the user didn't provide a path AND file name\n    // then we'll do our best to choose a default.\n    if ( ! this.output.name && defaultName) {\n        // We'll check to see if the provided src is not\n        // an array. If so, we'll use that single file\n        // name as the output name. But we must also\n        // change the extension (.sass -> .css).\n        if ( ! Array.isArray(this.src.path) && this.src.name.indexOf('*') == -1) {\n            defaultName = this.changeExtension(\n                this.src.name,\n                this.parse(defaultName).extension\n            );\n        }\n\n        this.output = this.parse(p.join(output, defaultName));\n    }\n\n    return this;\n};\n\n/**\n * Change the file extension for a path.\n *\n * @param  {string} path\n * @param  {string} newExtension\n * @return {string}\n */\nGulpPaths.prototype.changeExtension = function(path, newExtension) {\n    return gutils.replaceExtension(path, newExtension);\n};\n\n/**\n * Apply a path prefix to the path(s).\n *\n * @param  {string|Array} path\n * @param  {string|null}  prefix\n * @return {string|Array}\n */\nGulpPaths.prototype.prefix = function(path, prefix) {\n    if ( ! prefix) return path;\n\n    var prefixOne = function(path) {\n        // Given any path that begins with a period, we\n        // can safely assume that the user wants to\n        // skip the prefix and begin at the root.\n        if (path.indexOf('./') == 0) {\n            return path;\n        }\n\n        // If path starts with \"!\" we need to negate him\n        if (path.indexOf('!') == 0) {\n            path = '!' + p.join(prefix, path.substring(1));\n        } else {\n            path = p.join(prefix, path);\n        }\n\n        return path.replace(/\\/\\//g, '/')\n            .replace(/\\/\\//g, '/')\n            .replace(p.join(prefix, prefix), prefix);\n    };\n\n    if (Array.isArray(path)) {\n        return path.map(prefixOne);\n    }\n\n    return prefixOne(path);\n};\n\n/**\n * Parse the given file path.\n *\n * @param  {string} path\n * @return {object}\n */\nGulpPaths.prototype.parse = function(path) {\n    var segments = parsePath(path);\n\n    return {\n        path      : path,\n        name      : segments.extname ? segments.basename : '',\n        extension : segments.extname,\n        isDir     : ! (!! segments.extname),\n        baseDir   : segments.extname\n                        ? segments.dirname\n                        : p.join(segments.dirname, segments.basename)\n    };\n};\n\nmodule.exports = GulpPaths;\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/Logger.js":"var fs = require('fs');\nvar path = require('path');\nvar gutil = require('gulp-util');\n\n/**\n * Create a new Logger constructor.\n */\nvar Logger = function() {};\n\n/**\n * Log a heading to the console.\n *\n * @param  {string} heading\n * @return {Logger}\n */\nLogger.heading = function(heading) {\n    console.log(''); // line break\n\n    console.log(\n        gutil.colors.black(gutil.colors.bgGreen(heading))\n    );\n\n    return Logger;\n};\n\n/**\n * Log a general message to the console.\n *\n * @param  {string} message\n * @return {Logger}\n */\nLogger.message = function(message) {\n    console.log(message);\n\n    return Logger;\n};\n\n/**\n * Log a set of files to the console.\n *\n * @param  {string|Array} files\n * @param  {boolean}      checkForFiles\n * @return {Logger}\n */\nLogger.files = function(files, checkForFiles) {\n    files = Array.isArray(files) ? files : [files];\n    var spacer = '   - ';\n\n    files.forEach(function(file) {\n        if ( ! checkForFiles || assertFileExists(file)) {\n            console.log(spacer + file);\n        } else {\n            console.log(spacer + gutil.colors.bgRed(file) + ' <-- Not Found');\n        }\n    });\n\n    console.log(); // For a line break.\n\n    return Logger;\n};\n\n/**\n * Assert that the given file exists.\n *\n * @param  {string} file\n * @return {boolean}\n */\nvar assertFileExists = function(file) {\n    // If this file begins with a !, then the user\n    // intends to exclude it from their src set.\n    if (file.indexOf('!') == 0) {\n        file = file.slice(1);\n    }\n    \n    return file.match(/\\*/) || fs.existsSync(file);\n};\n\nmodule.exports = Logger;\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/Notification.js":"var notify = require('gulp-notify');\n\n/**\n * Create a new Notification instance.\n */\nvar Notification = function() {\n    this.title = 'Laravel Elixir';\n\n    // If an argument is provided, then we'll\n    // assume they want to show a message.\n    if (arguments.length) {\n        return this.message(arguments[0]);\n    }\n};\n\nvar n = Notification.prototype;\n\n/**\n * Display a notification.\n *\n * @param {string} message\n */\nn.message = function(message) {\n    return notify({\n        title: this.title,\n        message: message,\n        icon: __dirname + '/icons/laravel.png',\n        onLast: true\n    });\n};\n\n/**\n * Display an error notification.\n *\n * @param {object} e\n * @param {string} message\n */\nn.error = function(e, message) {\n    notify.onError({\n        title: this.title,\n        message: message + ': <%= error.message %>',\n        icon: __dirname + '/icons/fail.png',\n        onLast: true\n    })(e);\n\n    // We'll spit out the error, just in\n    // case it is useful for the user.\n    console.log(e);\n};\n\n/**\n * Display a notification for passed tests.\n *\n * @param {string} framework\n */\nn.forPassedTests = function(framework) {\n    return notify({\n        title: 'Green!',\n        message: 'Your ' + framework + ' tests passed!',\n        icon: __dirname + '/icons/pass.png',\n        onLast: true\n    });\n};\n\n/**\n * Display a notification for failed tests.\n *\n * @param {object} e\n * @param {string} framework\n */\nn.forFailedTests = function(e, framework) {\n    return notify.onError({\n        title: 'Red!',\n        message: 'Your ' + framework + ' tests failed!',\n        icon: __dirname + '/icons/fail.png',\n        onLast: true\n    })(e);\n};\n\nmodule.exports = Notification;\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/Task.js":"var _ = require('underscore');\n\nvar id = 0, Elixir;\n\n/**\n * Create a new Task instance.\n *\n * @param {string}   name\n * @param {Function} description\n */\nvar Task = function(name, description) {\n    this.id = id++;\n    this.name = name;\n    this.watchers = [];\n\n    if (description) {\n        this.describe(description);\n    }\n};\n\n/**\n * Fetch the task(s) with the given name.\n *\n * @param  {string} name\n * @return {Task}\n */\nTask.find = function(name) {\n    var tasks = _.where(Elixir.tasks, { name: name });\n\n    return tasks[Elixir.config.activeTasks[name]];\n};\n\n/**\n * Describe the task. This is the Gulp definition.\n *\n * @param  {Function} definition\n * @return {Task}\n */\nTask.prototype.describe = function(definition) {\n    this.definition = definition;\n\n    this.register();\n\n    return this;\n};\n\n/**\n * Set the task to be called, when firing `Gulp`.\n *\n * @return {Task}\n */\nTask.prototype.register = function() {\n    Elixir.tasks.push(this);\n\n    Elixir.config.activeTasks = Elixir.config.activeTasks || {};\n    Elixir.config.activeTasks[this.name] = 0;\n\n    return this;\n};\n\n/**\n * Set a path regex to watch for changes.\n *\n * @param  {string}      regex\n * @param  {string|null} category\n * @return {Task}\n */\nTask.prototype.watch = function(regex, category) {\n    if (regex) {\n        this.watchers.push(regex);\n    }\n\n    this.category = category || 'default';\n\n    return this;\n};\n\n/**\n * Exclude the given path from the watcher.\n *\n * @param  {string} path\n * @return {Task}\n */\nTask.prototype.ignore = function(path) {\n    this.watchers.push(('!./' + path).replace('././', './'));\n\n    return this;\n};\n\n/**\n * Execute the task definition.\n */\nTask.prototype.run = function() {\n    return this.definition();\n};\n\n/**\n * Log the task input and output.\n *\n * @param {string|Array} src\n * @param {string|null}  output\n */\nTask.prototype.log = function(src, output) {\n    var task = this.name.substr(0,1).toUpperCase() + this.name.substr(1);\n\n    Elixir.Log\n       .heading(\"Fetching \" + task + \" Source Files...\")\n       .files(src.path ? src.path : src, true);\n\n    if (output) {\n        Elixir.Log\n            .heading('Saving To...')\n            .files(output.path ? output.path : output);\n    }\n};\n\nmodule.exports = function(elixir) {\n    // Make Elixir available throughout this file.\n    Elixir = elixir;\n\n    return Task;\n};\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/browserify.js":"var gulp = require('gulp');\nvar gutil = require('gulp-util');\nvar watchify = require('watchify');\nvar buffer = require('vinyl-buffer');\nvar Elixir = require('laravel-elixir');\nvar browserify = require('browserify');\nvar source = require('vinyl-source-stream');\n\nvar bundle;\nvar $ = Elixir.Plugins;\nvar config = Elixir.config;\n\n/*\n |----------------------------------------------------------------\n | Browserify Task\n |----------------------------------------------------------------\n |\n | This task will manage your entire Browserify workflow, from\n | scratch! Also, it will channel all files through Babelify\n | so that you may use all the ES6 goodness you can stand.\n |\n */\n\nElixir.extend('browserify', function(src, output, baseDir, options) {\n    var paths = prepGulpPaths(src, baseDir, output);\n\n    new Elixir.Task('browserify', function() {\n        var stream = config.js.browserify.watchify.enabled\n            ? watchifyStream\n            : browserifyStream;\n\n        bundle = function(stream, paths) {\n            this.log(paths.src, paths.output);\n\n            return (\n                stream\n                .bundle()\n                .on('error', function(e) {\n                    new Elixir.Notification().error(e, 'Browserify Failed!');\n\n                    this.emit('end');\n                })\n                .pipe(source(paths.output.name))\n                .pipe(buffer())\n                .pipe($.if(config.sourcemaps, $.sourcemaps.init({ loadMaps: true })))\n                .pipe($.if(config.production, $.uglify()))\n                .pipe($.if(config.sourcemaps, $.sourcemaps.write('.')))\n                .pipe(gulp.dest(paths.output.baseDir))\n                .pipe(new Elixir.Notification('Browserify Compiled!'))\n            );\n        }.bind(this);\n\n        return bundle(\n            stream({\n                paths: paths,\n                options: options || config.js.browserify.options\n            }),\n            paths\n        );\n    })\n    // We'll add this task to be watched, but Watchify\n    // will handle the process, to speed things up.\n    .watch();\n});\n\n/**\n * Prep the Gulp src and output paths.\n *\n * @param  {string|Array} src\n * @param  {string|null}  baseDir\n * @param  {string|null}  output\n * @return {GulpPaths}\n */\nvar prepGulpPaths = function(src, baseDir, output) {\n    return new Elixir.GulpPaths()\n        .src(src, baseDir || config.get('assets.js.folder'))\n        .output(output || config.get('public.js.outputFolder'), 'bundle.js');\n};\n\n/**\n * Get a standard Browserify stream.\n *\n * @param {object} data\n */\nvar browserifyStream = function(data) {\n    var stream = browserify(data.paths.src.path, data.options);\n\n    config.js.browserify.transformers.forEach(function(transformer) {\n        stream.transform(\n            require(transformer.name), transformer.options || {}\n        );\n    });\n\n    config.js.browserify.plugins.forEach(function(plugin) {\n        stream.plugin(\n            require(plugin.name), plugin.options || {}\n        );\n    });\n\n    config.js.browserify.externals.forEach(function(external) {\n        stream.external(external);\n    });\n\n    return stream;\n};\n\n/**\n * Get a Browserify stream, wrapped in Watchify.\n *\n * @param {object} data\n */\nvar watchifyStream = function(data) {\n    var browserify = watchify(\n        browserifyStream(data),\n        config.js.browserify.watchify.options\n    );\n\n    browserify.on('log', gutil.log);\n    browserify.on('update', function() {\n        bundle(browserify, data.paths);\n    });\n\n    return browserify;\n};\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/browsersync.js":"var gulp = require('gulp');\nvar _ = require('underscore');\nvar gutils = require('gulp-util');\nvar Elixir = require('laravel-elixir');\nvar browserSync = require('browser-sync').create();\n\nvar config = Elixir.config;\n\n/*\n |----------------------------------------------------------------\n | BrowserSync\n |----------------------------------------------------------------\n |\n | Browsersync makes your browser testing workflow faster by\n | synchronizing URLs, behavior, and code changes across\n | across multiple devices. And, now it's in Elixir!\n |\n */\n\nElixir.extend('browserSync', function (options) {\n    options = _.extend(config.browserSync, {\n        files: [\n            config.appPath + '/**/*.php',\n            config.get('public.css.outputFolder') + '/**/*.css',\n            config.get('public.js.outputFolder') + '/**/*.js',\n            config.get('public.versioning.buildFolder') + '/rev-manifest.json',\n            config.viewPath +'/**/*.php'\n        ],\n        watchOptions: {\n            usePolling: true\n        },\n        snippetOptions: {\n            rule: {\n                match: /(<\\/body>|<\\/pre>)/i,\n                fn: function (snippet, match) {\n                    return snippet + match;\n                }\n            }\n        }\n    }, options);\n\n    // Browsersync will only run during `gulp watch`.\n    if (gutils.env._.indexOf('watch') > -1) {\n        browserSync.init(options);\n    }\n\n    new Elixir.Task('browserSync', function () {}).watch();\n});\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/coffee.js":"var gulp   = require('gulp');\nvar Elixir = require('laravel-elixir');\n\nvar $ = Elixir.Plugins;\nvar config = Elixir.config;\n\n/*\n |----------------------------------------------------------------\n | CoffeeScript Compilation\n |----------------------------------------------------------------\n |\n | This task will compile your CoffeeScript, minify it, and then\n | optionally generate a \"manifest\" file that helps with your\n | browser cache-busting of previous versions of your code.\n |\n */\n\nElixir.extend('coffee', function(src, output, options) {\n    var paths = prepGulpPaths(src, output);\n\n    new Elixir.Task('coffee', function() {\n        this.log(paths.src, paths.output);\n\n        return (\n            gulp\n            .src(paths.src.path)\n            .pipe($.if(config.sourcemaps, $.sourcemaps.init()))\n            .pipe($.coffee(options || config.js.coffee.options)\n                .on('error', function(e) {\n                    new Elixir.Notification().error(e, 'CoffeeScript Compilation Failed!');\n\n                    this.emit('end');\n                }))\n            .pipe($.concat(paths.output.name))\n            .pipe($.if(config.production, $.uglify()))\n            .pipe($.if(config.sourcemaps, $.sourcemaps.write('.')))\n            .pipe(gulp.dest(paths.output.baseDir))\n            .pipe(new Elixir.Notification('CoffeeScript Compiled!'))\n        );\n    })\n    .watch(paths.src.path)\n    .ignore(paths.output.path);\n});\n\n\n/**\n * Prep the Gulp src and output paths.\n *\n * @param  {string|Array} src\n * @param  {string|null}  output\n * @return {GulpPaths}\n */\nvar prepGulpPaths = function(src, output) {\n    return new Elixir.GulpPaths()\n        .src(src, config.get('assets.js.coffee.folder'))\n        .output(output || config.get('public.js.outputFolder'), 'app.js');\n};\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/combine.js":"var gulp   = require('gulp');\nvar Elixir = require('laravel-elixir');\n\nvar $ = Elixir.Plugins;\nvar config = Elixir.config;\n\n/*\n |----------------------------------------------------------------\n | File Concatenation\n |----------------------------------------------------------------\n |\n | This task will concatenate an array of files. Nothing more\n | nothing less. Note that, while, say, mix.scripts() runs\n | general compilation on the files, this one does not.\n |\n */\n\nElixir.extend('combine', function(src, output, baseDir) {\n    var paths = prepGulpPaths(src, baseDir, output);\n\n    new Elixir.Task('combine', function() {\n        this.log(paths.src, paths.output);\n\n        return (\n            gulp\n            .src(paths.src.path)\n            .pipe($.concat(paths.output.name))\n            .pipe(gulp.dest(paths.output.baseDir))\n        );\n    })\n    .watch(paths.src.path)\n    .ignore(paths.output.path);\n});\n\n\n/**\n * Prep the Gulp src and output paths.\n *\n * @param  {string|Array} src\n * @param  {string}       baseDir\n * @param  {string|null}  output\n * @return {GulpPaths}\n */\nvar prepGulpPaths = function(src, baseDir, output) {\n    return new Elixir.GulpPaths()\n        .src(src, baseDir || '')\n        .output(output);\n};\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/copy.js":"var gulp = require('gulp');\nvar Elixir = require('laravel-elixir');\n\nvar $ = Elixir.Plugins;\n\n/*\n |----------------------------------------------------------------\n | Copying\n |----------------------------------------------------------------\n |\n | This task offers a simple way to copy files from one place to\n | another. No more complicated than that! You may either set\n | a single file or alternatively you can copy a full dir.\n |\n */\n\nElixir.extend('copy', function(src, output) {\n    var paths = new Elixir.GulpPaths().src(src).output(output);\n\n    new Elixir.Task('copy', function() {\n        this.log(paths.src, paths.output);\n\n        return (\n            gulp\n            .src(paths.src.path)\n            .pipe($.if(! paths.output.isDir, $.rename(paths.output.name)))\n            .pipe(gulp.dest(paths.output.baseDir))\n        );\n    })\n    .watch(paths.src.path)\n    .ignore(paths.output.path);\n});\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/default.js":"var gulp = require('gulp');\nvar _ = require('underscore');\nvar Elixir = require('laravel-elixir');\nvar inSequence = require('run-sequence');\n\n/*\n |----------------------------------------------------------------\n | Default Task\n |----------------------------------------------------------------\n |\n | This task will run when the developer executes \"gulp\" on the\n | command line. We'll use this configuration object to know\n | which tasks should be fired when this task is executed.\n |\n */\n\ngulp.task('default', function() {\n    inSequence.apply(this, _.pluck(Elixir.tasks, 'name'));\n});\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/exec.js":"var gulp    = require('gulp');\nvar Elixir = require('laravel-elixir');\n\n/*\n |----------------------------------------------------------------\n | Shell Commands\n |----------------------------------------------------------------\n | \n | Need to execute a shell script, as part of your compile \n | process? No problem. Elixir can help with that. Just\n | call `mix.exec('command')`, and, bam, you're set!\n |\n */\n\nElixir.extend('exec', function(command, watcher) {\n    var task = new Elixir.Task('exec', function() {\n        Elixir.Log\n            .heading('Triggering Command...')\n            .message(command);\n\n        return (\n            gulp\n            .src('')\n            .pipe(Elixir.Plugins.shell(command))\n        );\n    });\n\n    if (watcher) {\n        task.watch(watcher);\n    }\n});\n\n\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/less.js":"var gulp    = require('gulp');\nvar compile = require('./shared/Css');\nvar Elixir = require('laravel-elixir');\n\nvar config = Elixir.config;\n\n/*\n |----------------------------------------------------------------\n | Less Compilation Task\n |----------------------------------------------------------------\n |\n | This task will compile your Less, including minification and\n | and auto-prefixing. Less is one of the CSS pre-processors\n | supported by Elixir, along with the Sass CSS processor.\n |\n */\n\nElixir.extend('less', function(src, output, options) {\n    var paths = prepGulpPaths(src, output);\n\n    new Elixir.Task('less', function() {\n        return compile({\n            name: 'Less',\n            compiler: require('gulp-less'),\n            src: paths.src,\n            output: paths.output,\n            task: this,\n            pluginOptions: options || config.css.less.pluginOptions\n        });\n    })\n    .watch(paths.src.baseDir + '/**/*.less')\n    .ignore(paths.output.path);\n});\n\n/**\n * Prep the Gulp src and output paths.\n *\n * @param  {string|Array} src\n * @param  {string|null}  output\n * @return {GulpPaths}\n */\nvar prepGulpPaths = function(src, output) {\n    return new Elixir.GulpPaths()\n        .src(src, config.get('assets.css.less.folder'))\n        .output(output || config.get('public.css.outputFolder'), 'app.css');\n};\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/phpspec.js":"var gulp   = require('gulp');\nvar Elixir = require('laravel-elixir');\n\nvar config = Elixir.config;\nvar runTests = require('./shared/Tests.js');\n\n\n/*\n |----------------------------------------------------------------\n | PHPSpec Testing\n |----------------------------------------------------------------\n |\n | This task will trigger your entire PHPUnit test suite and it\n | will show notifications indicating the success or failure\n | of that test suite. It works great with your tdd task.\n |\n */\n\nElixir.extend('phpSpec', function(src, command) {\n    runTests(\n        'PHPSpec',\n        src || (config.testing.phpSpec.path + '/**/*Spec.php'),\n        command || 'vendor/bin/phpspec run'\n    );\n});\n\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/phpunit.js":"var gulp   = require('gulp');\nvar Elixir = require('laravel-elixir');\n\nvar config = Elixir.config;\nvar runTests = require('./shared/Tests.js');\n\n\n/*\n |----------------------------------------------------------------\n | PHPUnit Testing\n |----------------------------------------------------------------\n |\n | This task will trigger your entire PHPUnit test suite and it\n | will show notifications indicating the success or failure\n | of that test suite. It works great with your tdd task.\n |\n */\n\nElixir.extend('phpUnit', function(src, command) {\n    runTests(\n        'PHPUnit',\n        src || (config.testing.phpUnit.path + '/**/*Test.php'),\n        command || 'vendor/bin/phpunit --verbose'\n    );\n});\n\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/sass.js":"var gulp    = require('gulp');\nvar compile = require('./shared/Css');\nvar Elixir = require('laravel-elixir');\n\nvar config = Elixir.config;\n\n/*\n |----------------------------------------------------------------\n | Sass Compilation Task\n |----------------------------------------------------------------\n |\n | This task will compile your Sass, including minification and\n | and auto-prefixing. Sass is one of the CSS pre-precessors\n | supported by Elixir, along with the Less CSS processor.\n |\n */\n\nvar gulpTask = function(src, output, options) {\n    var paths = prepGulpPaths(src, output);\n\n    new Elixir.Task('sass', function() {\n        return compile({\n            name: 'Sass',\n            compiler: require('gulp-sass'),\n            src: paths.src,\n            output: paths.output,\n            task: this,\n            pluginOptions: options || config.css.sass.pluginOptions\n        });\n    })\n    .watch(paths.src.baseDir + '/**/*.+(sass|scss)')\n    .ignore(paths.output.path);\n};\n\n\nElixir.extend('sass', function() {\n    gulpTask.apply(this, arguments);\n});\n\n\n// Deprecated. Only for backward compatibility.\nElixir.extend('rubySass', function() {\n    gulpTask.apply(this, arguments);\n});\n\n/**\n * Prep the Gulp src and output paths.\n *\n * @param  {string|Array} src\n * @param  {string|null}  output\n * @return {GulpPaths}\n */\nvar prepGulpPaths = function(src, output) {\n    return new Elixir.GulpPaths()\n        .src(src, config.get('assets.css.sass.folder'))\n        .output(output || config.get('public.css.outputFolder'), 'app.css');\n};\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/scripts.js":"var gulp = require('gulp');\nvar Elixir = require('laravel-elixir');\n\nvar $ = Elixir.Plugins;\nvar config = Elixir.config;\n\n/*\n |----------------------------------------------------------------\n | JavaScript File Concatenation\n |----------------------------------------------------------------\n |\n | This task will concatenate and minify your JavaScript files\n | in order. This provides a quick and simple way to reduce\n | the number of HTTP requests your application executes.\n |\n */\n\nElixir.extend('scripts', function(scripts, output, baseDir) {\n    var paths = prepGulpPaths(scripts, baseDir, output);\n\n    new Elixir.Task('scripts', function() {\n        return gulpTask.call(this, paths);\n    })\n    .watch(paths.src.path)\n    .ignore(paths.output.path);\n});\n\nElixir.extend('scriptsIn', function(baseDir, output) {\n    var paths = prepGulpPaths('**/*.js', baseDir, output);\n\n    new Elixir.Task('scriptsIn', function() {\n        return gulpTask.call(this, paths);\n    })\n    .watch(paths.src.path)\n    .ignore(paths.output.path);\n});\n\nElixir.extend('babel', function(scripts, output, baseDir, options) {\n    var paths = prepGulpPaths(scripts, baseDir, output);\n\n    new Elixir.Task('babel', function() {\n        var babelOptions = options || config.js.babel.options;\n\n        return gulpTask.call(this, paths, babelOptions);\n    })\n    .watch(paths.src.path)\n    .ignore(paths.output.path);\n});\n\n/**\n * Trigger the Gulp task logic.\n *\n * @param {GulpPaths}   paths\n * @param {object|null} babel\n */\nvar gulpTask = function(paths, babel) {\n    this.log(paths.src, paths.output);\n\n    return (\n        gulp\n        .src(paths.src.path)\n        .pipe($.if(config.sourcemaps, $.sourcemaps.init()))\n        .pipe($.concat(paths.output.name))\n        .pipe($.if(babel, $.babel(babel)))\n        .on('error', function(e) {\n            new Elixir.Notification().error(e, 'Babel Compilation Failed!');\n            this.emit('end');\n        })\n        .pipe($.if(config.production, $.uglify(config.js.uglify.options)))\n        .pipe($.if(config.sourcemaps, $.sourcemaps.write('.')))\n        .pipe(gulp.dest(paths.output.baseDir))\n        .pipe(new Elixir.Notification('Scripts Merged!'))\n    );\n};\n\n/**\n * Prep the Gulp src and output paths.\n *\n * @param  {string|Array} src\n * @param  {string|null}  baseDir\n * @param  {string|null}  output\n * @return {GulpPaths}\n */\nvar prepGulpPaths = function(src, baseDir, output) {\n    return new Elixir.GulpPaths()\n        .src(src, baseDir || config.get('assets.js.folder'))\n        .output(output || config.get('public.js.outputFolder'), 'all.js');\n};\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/styles.js":"var gulp = require('gulp');\nvar Elixir = require('laravel-elixir');\n\nvar $ = Elixir.Plugins;\nvar config = Elixir.config;\n\n/*\n |----------------------------------------------------------------\n | CSS File Concatenation\n |----------------------------------------------------------------\n |\n | This task will concatenate and minify your style sheet files\n | in order, which provides a quick and simple way to reduce\n | the number of HTTP requests your application fires off.\n |\n */\n\nElixir.extend('styles', function(styles, output, baseDir) {\n    var paths = prepGulpPaths(styles, baseDir, output);\n\n    new Elixir.Task('styles', function() {\n        return gulpTask.call(this, paths);\n    })\n    .watch(paths.src.path)\n    .ignore(paths.output.path);\n});\n\nElixir.extend('stylesIn', function(baseDir, output) {\n    var paths = prepGulpPaths('**/*.css', baseDir, output);\n\n    new Elixir.Task('stylesIn', function() {\n        return gulpTask.call(this, paths);\n    })\n    .watch(paths.src.path)\n    .ignore(paths.output.path);\n});\n\n/**\n * Trigger the Gulp task logic.\n *\n * @param {GulpPaths} paths\n */\nvar gulpTask = function(paths) {\n    this.log(paths.src, paths.output);\n\n    return (\n        gulp\n        .src(paths.src.path)\n        .pipe($.if(config.sourcemaps, $.sourcemaps.init()))\n        .pipe($.concat(paths.output.name))\n        .pipe($.if(config.production, $.cssnano(config.css.cssnano.pluginOptions)))\n        .pipe($.if(config.sourcemaps, $.sourcemaps.write('.')))\n        .pipe(gulp.dest(paths.output.baseDir))\n        .pipe(new Elixir.Notification('Stylesheets Merged!'))\n    );\n};\n\n/**\n * Prep the Gulp src and output paths.\n *\n * @param  {string|Array} src\n * @param  {string|null}  baseDir\n * @param  {string|null}  output\n * @return {GulpPaths}\n */\nvar prepGulpPaths = function(src, baseDir, output) {\n    return new Elixir.GulpPaths()\n        .src(src, baseDir || config.get('assets.css.folder'))\n        .output(output || config.get('public.css.outputFolder'), 'all.css');\n};\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/tdd.js":"var gulp = require('gulp');\nvar Elixir = require('laravel-elixir');\n\n/*\n |----------------------------------------------------------------\n | TDD Watcher\n |----------------------------------------------------------------\n |\n | This task will keep an eye on any tasks that are part of the\n | tdd category. By default this includes PHPUnit and PHPSpec\n | tests. Run `gulp tdd` and your tests will auto-trigger.\n |\n */\n\ngulp.task('tdd', function() {\n    new Elixir.Log.message('Watching for tests...');\n\n    Elixir.tasks\n        .filter(function(task) {\n            return task.category == 'tdd';\n        })\n        .forEach(function(task) {\n            gulp.watch(task.watchers, [task.name]);\n        });\n});\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/version.js":"var fs = require('fs');\nvar del = require('del');\nvar glob = require('glob');\nvar gulp = require('gulp');\nvar rev = require('gulp-rev');\nvar Elixir = require('laravel-elixir');\nvar vinylPaths = require('vinyl-paths');\nvar parsePath  = require('parse-filepath');\nvar publicPath  = Elixir.config.publicPath;\nvar revReplace = require('gulp-rev-replace');\n\n/*\n |----------------------------------------------------------------\n | Versioning / Cache Busting\n |----------------------------------------------------------------\n |\n | This task will append a small hash on the end of your file\n | and generate a manifest file which contains the current\n | \"version\" of the filename for the application to use.\n |\n */\n\nElixir.extend('version', function(src, buildPath) {\n    var paths = prepGulpPaths(src, buildPath);\n\n    new Elixir.Task('version', function() {\n        var files = vinylPaths();\n        var manifest = paths.output.baseDir + '/rev-manifest.json';\n\n        this.log(paths.src, paths.output);\n\n        emptyBuildPathFiles(paths.output.baseDir, manifest);\n\n        // We need to remove the publicPath from the output base to get the\n        // correct prefix path.\n        var filePathPrefix = paths.output.baseDir.replace(publicPath, '') + '/';\n\n        return (\n            gulp.src(paths.src.path, { base: './' + publicPath })\n            .pipe(gulp.dest(paths.output.baseDir))\n            .pipe(files)\n            .pipe(rev())\n            .pipe(revReplace({prefix: filePathPrefix}))\n            .pipe(gulp.dest(paths.output.baseDir))\n            .pipe(rev.manifest())\n            .pipe(gulp.dest(paths.output.baseDir))\n            .on('end', function() {\n                // We'll get rid of the duplicated file that\n                // usually gets put in the \"build\" folder,\n                // alongside the suffixed version.\n                del(files.paths, { force: true });\n\n                // We'll also copy over relevant sourcemap files.\n                copyMaps(paths.src.path, paths.output.baseDir);\n            })\n        );\n    })\n    .watch(paths.src.path);\n});\n\n/**\n * Prep the Gulp src and output paths.\n *\n * @param  {string|Array} src\n * @param  {string|null}  buildPath\n * @return {GulpPaths}\n */\nvar prepGulpPaths = function(src, buildPath) {\n    src = Array.isArray(src) ? src : [src];\n\n    return new Elixir.GulpPaths()\n        .src(src, Elixir.config.publicPath)\n        .output(buildPath || Elixir.config.get('public.versioning.buildFolder'));\n};\n\n/**\n * Empty all relevant files from the build directory.\n *\n * @param {string} buildPath\n * @param {string} manifest\n */\nvar emptyBuildPathFiles = function(buildPath, manifest) {\n    fs.stat(manifest, function(err, stat) {\n        if (! err) {\n            manifest = JSON.parse(fs.readFileSync(manifest));\n\n            for (var key in manifest) {\n                del.sync(buildPath + '/' + manifest[key], { force: true });\n            }\n        }\n    });\n};\n\n/**\n * Copy source maps to the build directory.\n *\n * @param {string} src\n * @param {string} buildPath\n */\nvar copyMaps = function(src, buildPath) {\n    src.forEach(function(file) {\n        // We'll first get any files from the src\n        // array that have companion .map files.\n\n        glob(file, {}, function(error, files) {\n            if (error) return;\n\n            files\n                .filter(function(file) {\n                    return fs.existsSync(file + '.map');\n                })\n                .forEach(function(file) {\n                    // We will loop over this files array, and\n                    // copy each map to the build directory.\n                    var map = file.replace(publicPath, buildPath);\n\n                    gulp.src(file + '.map').pipe(gulp.dest(parsePath(map).dirname));\n                });\n        });\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/watch.js":"var gulp = require('gulp');\nvar _ = require('underscore');\nvar batch = require('gulp-batch');\nvar Elixir = require('laravel-elixir');\n\n/*\n |----------------------------------------------------------------\n | Watcher\n |----------------------------------------------------------------\n |\n | When you want to keep an eye on your files for changes, and\n | then re-trigger Gulp, then you should use the gulp watch\n | command. This way, you can auto-compile on each save!\n |\n */\n\ngulp.task('watch', function() {\n    var tasks = _.sortBy(Elixir.tasks, 'name');\n    var mergedTasks = {};\n\n    if (isWatchingBrowserify(tasks)) {\n        Elixir.config.js.browserify.watchify.enabled = true;\n\n        gulp.start('browserify');\n    }\n\n    tasks.forEach(function(task) {\n        if (task.name in mergedTasks) {\n            return mergedTasks[task.name].watchers = _.union(mergedTasks[task.name].watchers, task.watchers);\n        }\n\n        mergedTasks[task.name] = {\n            name: task.name,\n            watchers: Array.isArray(task.watchers) ? task.watchers : [task.watchers]\n        };\n    });\n\n    _.sortBy(mergedTasks, 'name').forEach(function(task) {\n        if (task.watchers.length > 0) {\n            gulp.watch(task.watchers, batch(Elixir.config.batchOptions, function(events) {\n                events.on('end', gulp.start(task.name));\n            }));\n        }\n    });\n});\n\n/**\n * Determine if Browserify is included in the list.\n *\n * @param  {object} tasks\n * @return {boolean}\n */\nvar isWatchingBrowserify = function(tasks) {\n    return _.contains(_.pluck(tasks, 'name'), 'browserify');\n};\n","/home/travis/build/npmtest/node-npmtest-laravel-elixir/node_modules/laravel-elixir/tasks/shared/Css.js":"var gulp   = require('gulp');\nvar Elixir = require('../../index');\n\nvar $ = Elixir.Plugins;\nvar config = Elixir.config;\n\nmodule.exports = function(options) {\n    var name = options.name;\n\n    options.task.log(options.src, options.output);\n\n    return (\n        gulp\n        .src(options.src.path)\n        .pipe($.if(config.sourcemaps, $.sourcemaps.init()))\n        .pipe(options.compiler(options.pluginOptions))\n        .on('error', function(e) {\n            new Elixir.Notification().error(e, name + ' Compilation Failed');\n\n            this.emit('end');\n        })\n        .pipe($.if(config.css.autoprefix.enabled, $.autoprefixer(config.css.autoprefix.options)))\n        .pipe($.concat(options.output.name))\n        .pipe($.if(config.production, $.cssnano(config.css.cssnano.pluginOptions)))\n        .pipe($.if(config.sourcemaps, $.sourcemaps.write('.')))\n        .pipe(gulp.dest(options.output.baseDir))\n        .pipe(new Elixir.Notification(name + ' Compiled!'))\n    );\n};\n"}